<!DOCTYPE html>

<html>
<head>
  <title>Polygon.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="Point.html">
                Point.js
              </a>
            
              
              <a class="source" href="Polygon.html">
                Polygon.js
              </a>
            
              
              <a class="source" href="Shape.html">
                Shape.js
              </a>
            
              
              <a class="source" href="camera.html">
                camera.js
              </a>
            
              
              <a class="source" href="gfx.html">
                gfx.js
              </a>
            
              
              <a class="source" href="trig.html">
                trig.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Polygon.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Load dependencies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../obj'</span>);
<span class="hljs-keyword">var</span> Shape = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Shape'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Object definition</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> Polygon = obj.define(Shape, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  options = options || {};
<span class="hljs-comment">/*
  function checkPoints(points, size) {
    points.forEach(function(point){
      if (point.length != size) throw new Error('Array contains incorrect amount of points required ('+size+').');
    });

    return true;
  }

  var _default = {
    points: [
      [ 20, 20 ],
      [ 20, 40 ],
      [ 40, 40 ],
      [ 40, 20 ]
    ],
    position: [20, 20]
  };

  var points = ( options.points !== undefined ) ? options.points : _default.points;
  var position = ( options.position !== undefined ) ? options.position : _default.position;

  this.points = (function(){

    Points = (checkPoints(points, 2)) ? points : [];
    PointArray = [];

    Points.forEach(function(point){
      PointArray.push( Point( point ));
    });

    return PointArray;

  }());

  this.move(this.centroid().invert());
  this.move(Point(position));
  this.position = this.centroid();

  this.stroke = options.stroke || this.stroke;
  this.angle = options.angle || this.angle;
  this.fill = options.fill || this.fill;

*/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Object properties &amp; methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
}, {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Iterates over points. If at least one of a shape’s points are in shot, then draw.
If they’re all less than 0 or greater than canvas edge on x or y axis, do not draw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  inShot: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    canvas_size = topdown.gfx.getCanvasSize();

    var modx = topdown.gfx.camera.mod.x;
        mody = topdown.gfx.camera.mod.y;

    var viewport = {
      x:{
        lt: true, gt: true,
        min: modx(0),
        max: modx(canvas_size.x)
      },
      y: {
        lt: true, gt: true,
        min: mody(0),
        max: mody(canvas_size.y)
      }
    };

    for (var i = 0; i &lt; this.points.length; i++) {
      if(this.points[i].inShot()) return true;

      var points = this.points[i];

      viewport.x.lt = ( viewport.x.lt &amp;&amp; (points.x &lt; viewport.x.min) ) ? true : false;
      viewport.x.gt = ( viewport.x.gt &amp;&amp; (points.x &gt; viewport.x.max) ) ? true : false;
      viewport.y.lt = ( viewport.y.lt &amp;&amp; (points.y &lt; viewport.y.min) ) ? true : false;
      viewport.y.gt = ( viewport.y.gt &amp;&amp; (points.y &gt; viewport.y.max) ) ? true : false;
    }

    if (viewport.x.lt || viewport.y.lt || viewport.x.gt || viewport.y.gt) return false;
    */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>consider case when points are off shot but shape is not</p>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>More complex tests arise when a shape’s points are out of the bounds
of camera, but part of the shape will still fall in shot, ie a rotated
square or a triangle.</p>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>  denom = ((LineB2.Y – LineB1.Y) <em> (LineA2.X – LineA1.X)) –
    ((LineB2.X – lineB1.X) </em> (LineA2.Y - LineA1.Y))
  return denom != 0</p>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>alternatively generate bounding sphere and use that to calculate wether
or not to draw shape, less exact but possibly more efficient.</p>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><a href="http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/">http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/</a></p>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>see also:
  <a href="https://github.com/robhawkes/rawkets/blob/master/public/js/Game.js#L440">https://github.com/robhawkes/rawkets/blob/master/public/js/Game.js#L440</a></p>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Without a final algorithm it’s worth rendering this
content anyway incase it overlaps into the viewport.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Calls graphics method to render shape</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    if (!this.inShot()) return false;

    var
    ctx = topdown.gfx.getContext(),
    mod = topdown.gfx.camera.mod;

    ctx.fillStyle = this.fill;
    ctx.strokeStyle = this.stroke;
    ctx.beginPath();

    for(i = 0; i &lt; this.points.length; i++) {
      var point = this.points[i];
      var func = i ? 'lineTo' : 'moveTo';
      ctx[func](mod.x(point.x), mod.y(point.y));
    }

    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Iterates over points to move them by vector supplied in argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  move: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    var args = arguments;
    var vector;

    if(!args.length || args.length &gt; 2) return false;
    if(args.length == 1) vector = args[0];

    if(args.length == 2) {
      if( isNaN( args[0] ) || isNaN( args[1] ) ) return false;
      vector = Point(args);
    }

    if (false === vector instanceof Point)
      throw new Error('You can only move a point by the vector of another Point.');

    this.points.forEach(function(point){
      point.add(vector);
    });

    this.position = this.centroid();

    topdown.gfx.refreshBackground = true;
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
  teleport: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(point)</span> {</span>
    <span class="hljs-comment">/*
    var current = this.centroid();
    this.move(point.sub(current));
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Iterates over points to rotate them by angle supplied in argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  rotate: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(theta)</span> {</span>
    <span class="hljs-comment">/*
    var axis = this.position;

    this.points.forEach(function(point){
      point.rotate(axis, theta);
    });

    angle = (this.angle + theta) % (Math.PI*2);

    while(angle &lt; 0) angle += (Math.PI*2);

    this.angle = angle;

    topdown.gfx.refreshBackground = true;
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
  setAngle: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(angle)</span> {</span>
    <span class="hljs-comment">/*
    var axis = this.position;
    var theta = angle - this.angle;

    this.points.forEach(function(point){
      point.rotate(axis, theta);
    });

    this.angle = angle;

    topdown.gfx.refreshBackground = true;
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
  pointInPolygon: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(point)</span>{</span>
    <span class="hljs-comment">/*
    var
    counter = 0,
    x_inter,
    points = this.points;

    var p1 = points[0];
    for (var i = 1, l = points.length; i &lt;= l; i++) {
      var p2 = points[i%l];

      if (
        point.y &gt; Math.min(p1.y, p2.y) &amp;&amp;
        point.y &lt;= Math.max(p1.y, p2.y) &amp;&amp;
        point.x &lt;= Math.max(p1.x, p2.x) &amp;&amp;
        p1.y != p2.y
      ) {
        x_inter = (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x;
        if ( p1.x == p2.x || point.x &lt;= x_inter) {
          counter++;
        }
      }
      p1 = p2;
    }

    return ( counter % 2 == 1 );
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Collision algorithm</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  detectCollision: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    var args = arguments;

    if(args.length != 2) {
      throw new Error('Invalid number of arguments provided.');
    } else if ( !args[0] instanceof Point || !args[1] instanceof Point ) {
      throw new Error('Function requires two points to detect collision.');
    }

    var
    B1 = args[0],
    B2 = args[1],
    collision = false,
    points = this.points;

    if (this.pointInPolygon(B1) || this.pointInPolygon(B2)) {
      return true;
    }

    for(var i = 0, nPts = points.length; i &lt; nPts; i++) {
      var this_point = points[i];
      var next_point = points[(i+1)%nPts];

      var A1 = {
        x: this_point.x,
        y: this_point.y
      },
      A2 = {
        x: next_point.x,
        y: next_point.y
      };

      collision = ( collision || this.doesLineIntersect(A1, A2, B1, B2) );
    }

    return collision;
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
  getLineIntersectionPoint: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(A1, A2, B1, B2)</span> {</span>
    <span class="hljs-comment">/*
    var s1_x, s1_y, s2_x, s2_y;
    s1_x = A2.x - A1.x;
    s1_y = A2.y - A1.y;
    s2_x = B2.x - B1.x;
    s2_y = B2.y - B1.y;
    var s, t;
    s = (-s1_y * (A1.x - B1.x) + s1_x * (A1.y - B1.y)) / (-s2_x * s1_y + s1_x * s2_y);
    t = ( s2_x * (A1.y - B1.y) - s2_y * (A1.x - B1.x)) / (-s2_x * s1_y + s1_x * s2_y);

    if (s &gt;= 0 &amp;&amp; s &lt;= 1 &amp;&amp; t &gt;= 0 &amp;&amp; t &lt;= 1) {
</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Collision detected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> Point({
        x: A1.x + (t * s1_x),
        y: A1.y + (t * s1_y)
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>No collision</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    return false;
    */
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
  doesLineIntersect: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(A1, A2, B1, B2)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getLineIntersectionPoint(A1, A2, B1, B2) !== <span class="hljs-literal">false</span>;
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Returns the center point of shape.
TODO: doesnt calculate with only two points (ie straight line)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  centroid: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    var pts  = this.points;
    var nPts = pts.length;
    var x = 0; var y = 0;
    var f;
    var j = nPts - 1;
    var p1; var p2;

    for (var i = 0; i &lt; nPts; j = i++) {
      p1 = pts[i];
      p2 = pts[j];
      f  = p1.x * p2.y - p2.x * p1.y;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
    }

    f = this.area() * 6;

    return Point([ x/f, y/f ]);
    */</span>
  },</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Returns area of shape</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  area: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">/*
    var
    area = 0,
    pts = this.points,
    p1, p2;

    for (var i=0, nPts = pts.length, j = nPts - 1; i &lt; nPts; j = i++) {
      p1 = pts[i];
      p2 = pts[j];
      area += p1.x * p2.y;
      area -= p1.y * p2.x;
    }

    area /= 2;

    return area;
    */</span>
  },

});</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Expose to browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
window.Polygon = Polygon;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Expose to other internal modules</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
module.exports = Polygon;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
